- 元组 
   - 任意对象的有序集合。
   - 通过偏移量存取
   - 属于不可变序列。
   - 固定长度，多样性，任意嵌套
   - 对象引用的数组
   - 元组的圆括号可以忽略，除了出现在一个函数调用中，或是嵌套在一个更大的表达式内。
   - 圆括号有助于增加脚本的可读性。
- 列表推导可以用在任何可迭代对象上。
- 元组的不可变性只适用于元组的顶层而非其内容，如果元组嵌套一个列表，该列表是可以改变的。
- 元组的不可变性提供了某种一致性，这样你可以确保元组在程序中不会被另一个引用修改。
- 列表适用于可能需要进行修改的有序集合，元组能够处理其他固定关系的情况。
- 具名元组
```python
from collections import namedtuple
Rec = namedtuple('Rec', ['name', 'age', 'jobs'])
bob = Rec('Bob', age=40.5, jobs=['dev', 'mgr'])
print(bob)  # Rec(name='Bob', age=40.5, jobs=['dev', 'mgr'])
```
- 文件
  - 文件迭代器最适合逐行读取
  - 内容是字符串不是对象
  - 文件是被缓冲的以及可定位的
  - close通常是可选的：回收时自动关闭。
- 常见的文件操作：
- 在Python3.0:
  - 文本文件把内容表示为常规的str字符串，自动执行Unicode编码和解码，并且默认执行行末换行。
  - 二进制文件把内容表示为一个特殊的bytes字节串类型，并且允许程序不修改地访问文件内容。
- 要转换文件所存储的列表和字典，我们可以运行eval()函数
- pickle模块可以让我们在文件中存储几乎任何Python对象的高级工具
```python
D = {'a':1,'b':2 }
F = open('datafile.pkl','wb')
import pickle
pickle.dump(D,F)
F.close()
F = open('datafile.pkl','wb')
E = pickle.load(F)
print(E)  # D = {'a':1,'b':2 }
```
- 在Python对象和文件中，JSON数据字符串之间的相互转换都是非常直接的，一旦你将JSON文本转换成Python对象之后，你就可以用一般的Python对象操作来处理数据。
- csv模块支持Python对象与XML格式的相互转换。
- struct模块能够构造并解析打包二进制数据。
```python
import struct

F = open('data.bin', 'wb')
data = struct.pack('>i4sh', 7, b'spam', 8)
print(data)  #b'\x00\x00\x00\x07spam\x00\x08'
F.write('data')
F.close()
F = open('data.bin', 'rb')
data = F.read()
print(data)  #b'\x00\x00\x00\x07spam\x00\x08'
values = struct.unpack('>i4sh', data)  #(7, b'spam', 8)
print(values)
```
- 文件上下文管理器：with
  - 在所有Python版本中都能保证操作系统资源的释放，而且对于确保刷新输出文件缓冲区更加有用
- Python中的其他文件工具：
  - 标准流：在sys模块中预先打开的文件对象
  - os模块中的描述文件：文件的整数参数，能够支持如文件锁定之类的较低级工具
  - 套接字、管道和FiFO文件：用于同步进程或者通过网络进行通信的类文件对象。
  - 通过键来存取的文件：如shelve模块
  - shell命令流：如os.popen和subprocess.Popen
- 核心类型复习与总结：
  - 按照分类：一些对象拥有共同的操作。
  - 只有可变对象（列表、字典和集合）可以在原位置修改；
  - 文件只导出方法，因此可变性并不用于它们————当处理文件的时候，它们的状态可能会改变，但这与Python核心类型所描述的可变性完全是两种含义。
  - 数字类型：整数、浮点数、复数、小数和分数
  - 字符串：str、bytes(python3.x)、unicode(python2.X)
  - 集合很像一个没有值只有键的字典，不能进行映射，也没有顺序。
- 对象灵活性：
  - 列表、字典和元组可以包含任何种类的对象。
  - 集合可以包含任意的不可变类型对象。
  - 列表、字典和元组可以进行任意嵌套
  - 列表、字典和元组可以动态地、扩大和缩小。
- 引用与复制
  - 没有参数的分片表达式(L[:])可以复制序列。(但是复制不了多维数组)
  - 想要复制多维数组可以采用分片表达式加推导式：
```python
a = [[1, 2, 3],
     [4, 5, 6],
     [7, 8, 9]]
b = [a[x][:] for x in a]
```
  - 字典、集合或列表的copy方法也可以复制
  - 一些内置函数可以进行复制（list(L)、dict(D)、set(S))
  - copy标准库模块能够在需要时创建完整副本。
  - 无参数的分片以及copy方法只能进行顶层复制，它们不能复制嵌套的数据结构。
- 比较、等价性和真值
  - "=="运算符测试值的等价性
  - "is"表达式测试对象的同一性：在存储器中的相同地址。
  - Python内部会对临时存储并重复使用短字符串做优化。
  - 数字在转换成必要的公共最高级类型后，才比较数值的相对大小
  - 字符串按照字母字典顺序比较，一个字符接一个字符地比对，直到末尾或发现第一处区别。
  - 列表和元组从左到右对每个组件地内容进行比较，而且对嵌套结构地比较是递归的，直到末尾或发现第一处区别。
  - 集合是相等的，当且仅当它们含有相同的元素（两者互为子集）。集合的相对大小比较采用子集和超集的检验标准。
  - 字典通过比较排序之后的(key,value)列表来判断是否相同（python3.X不支持）
  - python2.X允许非数字混合类型相对大小的比较。
  - 在python3.x中，可以手动比较排序的键/值列表：
```python
D1 = {'a': 1, 'b': 3}
D2 = {'a': 1, 'b': 3}
print(sorted(D1.items()) < sorted(D2.items()))  # False
```